「系統分析網站」核心業務邏輯規格（AI 產碼用）- 優化版

目標：本規格涵蓋核心業務邏輯、資料結構、認證與權限控制系統。供 AI 直接產生後端程式碼（CRUD、關聯、解析與一致性檢查、認證中介軟體、權限控制）與基本前端串接。

⚠️ 重要變更說明：
- 統一使用 UUID 作為所有 ID 欄位，避免代碼混用問題
- 新增完整的刪除策略與約束定義
- 強化併發處理與交易機制
- 改善 API 設計與錯誤處理
- 優化資料庫索引與約束
- 新增批量操作與分頁支援
- **新增完整的認證與權限控制系統**
- **強化資料安全與存取控制**

0) 名詞與範疇

Module（功能模組）：以業務能力分組的容器（例：登入與安全）。

Use Case（使用者案例）：使用者與系統互動的一個目標（例：登入）。

Sequence Diagram（循序圖）：以 Mermaid 撰寫的流程圖，對應 Use Case。

API Contract（API 合約）：方法 + 路徑 + 標題 + 說明。

DTO Schema（資料傳輸物件）：Request/Response 的結構描述（以 JSON Schema 儲存）。

Link（關聯）：API ↔ Sequence（步驟）、API ↔ DTO（req/res 角色）。

目標使用流程：Module → Use Case → Sequence Diagram → API/DTO（鏈結可追溯）。

1) 識別碼與代碼規範

1.1 代碼格式（自動生成）

MOD-{NNN}：Module 代碼（例：MOD-001），三位數起，溢出繼續增長（如 MOD-1001）

UC-{NNN}：Use Case 代碼（例：UC-001），以 Module 為 Scope

SD-{NNN}：Sequence 代碼（例：SD-001），以 Use Case 為 Scope

API-{DOMAIN}-{NNN}：API 代碼（例：API-AUTH-001），DOMAIN 為業務領域（如 AUTH、ORDER），若無則用 GEN

DTO-{Name}-{NNN}：DTO 代碼（例：DTO-LoginRequest-001），Name 取自 title 的英數駝峰基底

代碼在專案內唯一。NNN 預設 3 位左補零（001、002…），超過 999 仍繼續：1000、1001…

1.2 流水號 Scope 規則

類型｜Scope Key｜說明
---|---|---
Module｜project_id + type=MODULE｜專案底下逐號
Use Case｜project_id + type=USE_CASE + module_id｜每個模組自己的流水
Sequence｜project_id + type=SEQUENCE + use_case_id｜每個用例自己的流水
API｜project_id + type=API + domain｜每個 domain 自己的流水
DTO｜project_id + type=DTO + dto_name_base｜同名基底共用流水

1.3 流水號生成機制

- 採用計數器表（seq_counter）管理各 Scope 的流水號
- 使用行級鎖保證併發安全
- 編號只增不減，刪除資源不回收編號
- 交易內原子性分配，確保唯一性
- 新增重試機制：鎖定失敗時自動重試最多 3 次，間隔 100ms
- 批量建立時使用單一交易，避免多次鎖表

1.4 代碼生成錯誤處理

- DTO title 萃取失敗時，使用 fallback 命名：DTO-Unknown-{NNN}
- domain 參數不合法時，自動轉換為 "GEN"
- 所有代碼生成錯誤記錄到系統日誌，不中斷操作

2) 資料模型（最小必要欄位）

2.1 User（用戶認證）

id (uuid) // 統一使用 UUID 格式
email (string) // 唯一，用於登入
password (string) // bcrypt 雜湊後的密碼
name (string?) // 顯示名稱
role (string) // 角色：user, admin, super_admin
isActive (boolean) // 帳號是否啟用
isLocked (boolean) // 帳號是否被鎖定
lockReason (string?) // 鎖定原因
failedLoginAttempts (int) // 登入失敗次數
lastLoginAt (timestamp?) // 最後登入時間
lastPasswordChange (timestamp?) // 最後密碼變更時間
emailVerified (boolean) // Email 是否已驗證
emailVerificationToken (string?) // Email 驗證 Token
passwordResetToken (string?) // 密碼重設 Token
passwordResetExpires (timestamp?) // 密碼重設 Token 過期時間
createdAt (timestamp)
updatedAt (timestamp)

2.2 RefreshToken（刷新 Token 管理）

id (uuid)
userId (uuid) // 外鍵，使用 UUID
token (string) // Refresh Token 值
deviceInfo (string?) // 裝置資訊
ipAddress (string?) // IP 位址
expiresAt (timestamp) // 過期時間
isRevoked (boolean) // 是否已撤銷
revokedAt (timestamp?) // 撤銷時間
createdAt (timestamp)

2.3 Project

id (uuid) // 統一使用 UUID 格式
name (string)
description (string?)
owner_id (uuid) // 專案擁有者，外鍵到 User
status (string) // 專案狀態：PLANNING | IN_PROGRESS | REVIEW | COMPLETED
created_at (timestamp)
updated_at (timestamp)

2.4 ProjectMember（專案成員權限）

id (uuid)
project_id (uuid) // 外鍵到 Project
user_id (uuid) // 外鍵到 User
role (string) // 角色：OWNER | EDITOR | VIEWER
permissions (jsonb) // 詳細權限設定
invited_by (uuid?) // 邀請人，外鍵到 User
invited_at (timestamp) // 邀請時間
accepted_at (timestamp?) // 接受邀請時間
created_at (timestamp)
updated_at (timestamp)

2.2 Module

id (uuid)

project_id (uuid) // 外鍵，使用 UUID

mod_code (string) // MOD-xxx

title (string)

parent_id (uuid?) // 允許樹狀，使用 UUID

order (int?) // 自動維護，插入時自動分配

created_at (timestamp)

updated_at (timestamp)

2.3 UseCase

id (uuid)

project_id (uuid)

module_id (uuid)

uc_code (string) // UC-xxx

title (string)

summary (string?)

created_at (timestamp)

updated_at (timestamp)

2.4 SequenceDiagram

id (uuid)

project_id (uuid)

use_case_id (uuid)

sd_code (string) // SD-xxx

title (string)

mermaid_src (text) // 原始碼

created_at (timestamp)

updated_at (timestamp)

2.5 ApiContract

id (uuid)

project_id (uuid)

api_code (string) // API-...

method (enum: GET|POST|PUT|DELETE|PATCH)

path (string) // 例：/auth/login

title (string)

desc (string?)

created_at (timestamp)

updated_at (timestamp)

2.6 DtoSchema

id (uuid)

project_id (uuid)

dto_code (string) // DTO-...

title (string)

schema_json (jsonb) // JSON Schema 物件，使用 JSONB 提升效能

kind (enum: request|response)

created_at (timestamp)

updated_at (timestamp)

2.7 Link：ApiSequenceLink

id (uuid)

api_id (uuid) // 外鍵，使用 UUID

sequence_id (uuid) // 外鍵，使用 UUID

step_ref (string) // 圖中步驟的參照標識（自訂文字）

line_number (int?) // 新增：Mermaid 原始碼中的行號，便於定位

created_at (timestamp)

2.8 Link：ApiDtoLink

id (uuid)

api_id (uuid) // 外鍵，使用 UUID

dto_id (uuid) // 外鍵，使用 UUID

role (enum: req|res)

created_at (timestamp)

3) Mermaid 解析規範（供一致性檢查使用）

3.1 解析時機與策略

- 同步解析：建立/更新 Sequence Diagram 時立即解析
- 異步解析：大量資料時使用背景任務，避免阻塞
- 快取機制：解析結果快取 5 分鐘，提升重複查詢效能

3.2 API 標記格式

標準：[API:API-AUTH-001] 文字說明…

寬鬆：包含 API-AUTH-001 即視為 API 參照

3.3 DTO 標記格式

Login(LoginRequest) -> LoginResponse

或在文字中出現 DTO-LoginRequest-001 / DTO-LoginResponse-001

3.4 解析規則（建議 regex）

API：/\[API:([A-Z0-9-]+)\]/g，若未命中則退化：/\bAPI-[A-Z0-9-]+\b/g

DTO：/\bDTO-[A-Za-z0-9-]+\b/g 或以括號語法抽取名稱後映射代碼

3.5 一致性檢查的最低要求

循序圖能抽出至少一個 API 代碼。DTO 可由 API 關聯補足。

4) 核心業務流程

4.1 建立分析骨架

建立 Project → Module

Module 下建立 Use Case

Use Case 下建立 SequenceDiagram（填 mermaid_src）

從循序圖解析或人工指定產生 ApiContract

為 API 綁定 DTO（至少 1 個 req + 1 個 res）

4.2 追溯（Traceability）

任意資源可向上查：API → Sequence → Use Case → Module

任意 Use Case 可展開：Sequences, APIs, DTOs

4.3 一致性檢查（Consistency）

以專案為單位檢查：

循序圖標記的 API 是否存在 ApiContract？

每個 API 是否至少綁定 1 req + 1 res DTO？

孤兒：未被任何 Sequence 參照的 API；未被任何 API 參照的 DTO

回傳缺失與孤兒清單，包含詳細位置資訊。

5) 認證與權限控制系統

5.1 認證中介軟體（Authentication Middleware）

5.1.1 JWT Token 驗證
- 所有受保護的 API 必須在 Header 中攜帶 `Authorization: Bearer <token>`
- Token 過期時自動回傳 401 錯誤
- 無效 Token 時回傳 401 錯誤
- 支援 Token 自動刷新機制

5.1.2 認證中介軟體實作
```typescript
// auth.middleware.ts
export const authenticateToken = async (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({
      success: false,
      error: { code: 'AUTH_TOKEN_MISSING', message: '缺少認證 Token' }
    });
  }
  
  try {
    const payload = await authService.verifyAccessToken(token);
    req.user = payload; // 將使用者資訊附加到請求物件
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      error: { code: 'AUTH_TOKEN_INVALID', message: 'Token 無效或已過期' }
    });
  }
};
```

5.2 權限控制中介軟體（Authorization Middleware）

5.2.1 專案權限檢查
- 檢查使用者是否有權限存取特定專案
- 支援三種角色：OWNER（擁有者）、EDITOR（編輯者）、VIEWER（唯讀者）
- 基於專案成員表進行權限驗證

5.2.2 權限檢查中介軟體實作
```typescript
// permission.middleware.ts
export const checkProjectPermission = (requiredRole: 'OWNER' | 'EDITOR' | 'VIEWER') => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const { projectId } = req.params;
    const userId = req.user.userId;
    
    try {
      const member = await projectService.getProjectMember(projectId, userId);
      
      if (!member) {
        return res.status(403).json({
          success: false,
          error: { code: 'PERMISSION_DENIED', message: '無權限存取此專案' }
        });
      }
      
      // 檢查角色權限
      const roleHierarchy = { 'OWNER': 3, 'EDITOR': 2, 'VIEWER': 1 };
      if (roleHierarchy[member.role] < roleHierarchy[requiredRole]) {
        return res.status(403).json({
          success: false,
          error: { code: 'INSUFFICIENT_PERMISSION', message: '權限不足' }
        });
      }
      
      req.projectMember = member; // 將專案成員資訊附加到請求物件
      next();
    } catch (error) {
      next(error);
    }
  };
};
```

5.3 權限模型設計

5.3.1 角色權限定義
- **OWNER（擁有者）**：
  - 完全控制權限
  - 可刪除專案
  - 可邀請/移除成員
  - 可修改專案設定
- **EDITOR（編輯者）**：
  - 可編輯專案內容
  - 可建立/修改/刪除模組、用例、API 等
  - 不可刪除專案
  - 不可邀請/移除成員
- **VIEWER（唯讀者）**：
  - 只能查看專案內容
  - 不可進行任何修改操作

5.3.2 權限檢查時機
- **讀取操作**：需要 VIEWER 以上權限
- **建立操作**：需要 EDITOR 以上權限
- **修改操作**：需要 EDITOR 以上權限
- **刪除操作**：需要 OWNER 權限
- **成員管理**：需要 OWNER 權限

6) REST API（優化版）

所有端點預設同一 base，例如 /v1。回應以 application/json。

**重要變更**：所有業務 API 都需要認證，並根據權限進行存取控制。

5.1 認證 API

5.1.1 用戶登入
POST /auth/login
請求：
```json
{
  "email": "user@example.com",
  "password": "password123"
}
```

回應：
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid-123",
      "email": "user@example.com",
      "name": "使用者名稱",
      "role": "user"
    },
    "tokens": {
      "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "expiresIn": 900,
      "refreshExpiresIn": 604800
    }
  }
}
```

5.1.2 重新整理 Token
POST /auth/refresh
請求：
```json
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

回應：
```json
{
  "success": true,
  "data": {
    "tokens": {
      "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "expiresIn": 900,
      "refreshExpiresIn": 604800
    }
  }
}
```

5.1.3 用戶登出
POST /auth/logout
請求：
```json
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

回應：
```json
{
  "success": true,
  "data": {
    "message": "登出成功"
  }
}
```

5.1.4 取得個人資料
GET /auth/profile
回應：
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid-123",
      "email": "user@example.com",
      "name": "使用者名稱",
      "role": "user",
      "isActive": true,
      "lastLoginAt": "2024-01-01T00:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z"
    }
  }
}
```

5.1.5 更新個人資料
PATCH /auth/profile
請求：
```json
{
  "name": "新使用者名稱"
}
```

回應：
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid-123",
      "email": "user@example.com",
      "name": "新使用者名稱",
      "role": "user",
      "updatedAt": "2024-01-01T00:00:00Z"
    }
  }
}
```

5.1.6 修改密碼
PATCH /auth/password
請求：
```json
{
  "currentPassword": "oldpassword123",
  "newPassword": "newpassword123"
}
```

回應：
```json
{
  "success": true,
  "data": {
    "message": "密碼修改成功"
  }
}
```

5.2 專案管理 API

5.1 統一回應格式

成功回應：
```json
{
  "success": true,
  "data": { ... },
  "timestamp": "2024-01-01T00:00:00Z"
}
```

錯誤回應：
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "詳細錯誤訊息",
    "details": { ... }
  },
  "timestamp": "2024-01-01T00:00:00Z"
}
```

5.2 分頁支援

所有列表 API 支援分頁：
```json
{
  "success": true,
  "data": { ... },
  "pagination": {
    "page": 1,
    "size": 20,
    "total": 100,
    "total_pages": 5
  }
}
```

5.3 Project

POST /projects → 建立（需要認證）
GET /projects → 讀取專案列表（需要認證，只顯示有權限的專案）
GET /projects/:id → 讀取專案詳情（需要認證，需要 VIEWER 以上權限）
PATCH /projects/:id → 更新（需要認證，需要 EDITOR 以上權限）
DELETE /projects/:id → 刪除（需要認證，需要 OWNER 權限）

5.3.1 專案成員管理
POST /projects/:id/members → 邀請成員（需要認證，需要 OWNER 權限）
GET /projects/:id/members → 取得成員列表（需要認證，需要 VIEWER 以上權限）
PATCH /projects/:id/members/:memberId → 修改成員權限（需要認證，需要 OWNER 權限）
DELETE /projects/:id/members/:memberId → 移除成員（需要認證，需要 OWNER 權限）

5.4 Module

POST /modules → 建立（需要認證，需要 EDITOR 以上權限）
GET /modules?project_id=...&page=1&size=20&parent_id=... → 讀取（需要認證，需要 VIEWER 以上權限）
PATCH /modules/:id → 更新（需要認證，需要 EDITOR 以上權限）
DELETE /modules/:id → 刪除（需要認證，需要 EDITOR 以上權限）

POST /modules/batch → 批量建立（需要認證，需要 EDITOR 以上權限）

請求例（mod_code 由後端自動生成，order 自動分配）
```json
POST /modules
{
  "project_id": "uuid-123",
  "title": "登入與安全",
  "parent_id": null
}
```

回應
```json
{
  "success": true,
  "data": {
    "id": "uuid-123",
    "project_id": "uuid-123",
    "mod_code": "MOD-001",
    "title": "登入與安全",
    "parent_id": null,
    "order": 10,
    "created_at": "2024-01-01T00:00:00Z"
  }
}
```

5.5 Use Case

POST /use-cases → 建立（需要認證，需要 EDITOR 以上權限）
GET /use-cases?project_id=...&module_id=...&page=1&size=20 → 讀取（需要認證，需要 VIEWER 以上權限）
PATCH /use-cases/:id → 更新（需要認證，需要 EDITOR 以上權限）
DELETE /use-cases/:id → 刪除（需要認證，需要 EDITOR 以上權限）

POST /use-cases/batch → 批量建立（需要認證，需要 EDITOR 以上權限）

5.6 Sequence Diagram

POST /sequences → 建立（需要認證，需要 EDITOR 以上權限）
GET /sequences?project_id=...&use_case_id=...&page=1&size=20 → 讀取（需要認證，需要 VIEWER 以上權限）
PATCH /sequences/:id → 更新（需要認證，需要 EDITOR 以上權限）
DELETE /sequences/:id → 刪除（需要認證，需要 EDITOR 以上權限）

POST /sequences/batch → 批量建立（需要認證，需要 EDITOR 以上權限）

5.7 API Contract

POST /apis → 建立（需要認證，需要 EDITOR 以上權限）
GET /apis?project_id=...&domain=...&method=...&page=1&size=20 → 讀取（需要認證，需要 VIEWER 以上權限）
PATCH /apis/:id → 更新（需要認證，需要 EDITOR 以上權限）
DELETE /apis/:id → 刪除（需要認證，需要 EDITOR 以上權限）

POST /apis/batch → 批量建立（需要認證，需要 EDITOR 以上權限）

5.8 DTO Schema

POST /dtos → 建立（需要認證，需要 EDITOR 以上權限）
GET /dtos?project_id=...&kind=...&page=1&size=20 → 讀取（需要認證，需要 VIEWER 以上權限）
PATCH /dtos/:id → 更新（需要認證，需要 EDITOR 以上權限）
DELETE /dtos/:id → 刪除（需要認證，需要 EDITOR 以上權限）

POST /dtos/batch → 批量建立（需要認證，需要 EDITOR 以上權限）

5.9 Link：API ↔ Sequence（步驟關聯）

POST /api-sequence-links → 建立（需要認證，需要 EDITOR 以上權限）
GET /api-sequence-links?sequence_id=...&api_id=...&page=1&size=20 → 讀取（需要認證，需要 VIEWER 以上權限）
DELETE /api-sequence-links/:id → 刪除（需要認證，需要 EDITOR 以上權限）

POST /api-sequence-links/batch → 批量建立（需要認證，需要 EDITOR 以上權限）

5.10 Link：API ↔ DTO（角色綁定）

POST /api-dto-links → 建立（需要認證，需要 EDITOR 以上權限）
GET /api-dto-links?api_id=...&role=...&page=1&size=20 → 讀取（需要認證，需要 VIEWER 以上權限）
DELETE /api-dto-links/:id → 刪除（需要認證，需要 EDITOR 以上權限）

POST /api-dto-links/batch → 批量建立（需要認證，需要 EDITOR 以上權限）

5.11 統一清單（供左側樹一次載入，支援分頁）

GET /catalog?project_id=...&page=1&size=100（需要認證，需要 VIEWER 以上權限）

回應
```json
{
  "success": true,
  "data": {
    "modules": [
      { "id":"uuid-1","mod_code":"MOD-001","title":"登入與安全","parent_id":null,"order":10 }
    ],
    "use_cases": [
      { "id":"uuid-2","module_id":"uuid-1","uc_code":"UC-001","title":"登入","summary":"..." }
    ],
    "sequences": [
      { "id":"uuid-3","use_case_id":"uuid-2","sd_code":"SD-001","title":"登入流程" }
    ],
    "apis": [
      { "id":"uuid-4","api_code":"API-AUTH-001","method":"POST","path":"/auth/login","title":"登入 API" }
    ],
    "dtos": [
      { "id":"uuid-5","dto_code":"DTO-LoginRequest-001","title":"LoginRequest","kind":"request" }
    ]
  },
  "pagination": {
    "page": 1,
    "size": 100,
    "total": 5,
    "total_pages": 1
  }
}
```

5.12 追溯（從任一資源出發）

GET /trace/chain?api_id=...&sequence_id=...&use_case_id=...&module_id=...（需要認證，需要 VIEWER 以上權限）

參數可換，回傳相鄰關聯鏈。

回應（以 api_id 為例）
```json
{
  "success": true,
  "data": {
    "api": { "id":"uuid-1","api_code":"API-AUTH-001","title":"登入 API" },
    "sequences": [{ "id":"uuid-2","sd_code":"SD-001","title":"登入流程" }],
    "use_case": { "id":"uuid-3","uc_code":"UC-001","title":"登入" },
    "module": { "id":"uuid-4","mod_code":"MOD-001","title":"登入與安全" }
  }
}
```

5.13 一致性檢查（核心，增強版）

POST /consistency/check?project_id=...（需要認證，需要 VIEWER 以上權限）

伺服器端會：

掃描該專案所有 SequenceDiagram.mermaid_src

解析 API 代碼 → 檢查 ApiContract 存在

檢查 API 是否具備 req 與至少一個 res DTO

找出孤兒 API/DTO

回應
```json
{
  "success": true,
  "data": {
    "missing_refs": {
      "apis": [
        { 
          "api_code": "API-ORDER-999",
          "referenced_in": [
            { "sequence_id": "uuid-1", "sequence_title": "訂單流程", "line_number": 15 }
          ]
        }
      ],
      "dtos": [
        { 
          "api_code": "API-AUTH-001",
          "missing": "req",
          "api_title": "登入 API"
        }
      ]
    },
    "orphans": {
      "apis": [
        { 
          "api_code": "API-PAY-003",
          "api_title": "支付 API",
          "created_at": "2024-01-01T00:00:00Z"
        }
      ],
      "dtos": [
        { 
          "dto_code": "DTO-Legacy-OldResponse-001",
          "dto_title": "Legacy Response",
          "created_at": "2024-01-01T00:00:00Z"
        }
      ]
    },
    "stats": {
      "sequences_scanned": 12,
      "apis_referenced": 28,
      "apis_defined": 30,
      "dtos_defined": 56,
      "links_checked": 84
    }
  }
}
```

5.14 AI 草稿產生與採用（優化版）

POST /ai/generate（需要認證，需要 EDITOR 以上權限）

請求
```json
{
  "project_id": "uuid-123",
  "context": { "module_id": "uuid-456", "use_case_id": null },
  "prompt": "新增忘記密碼流程，Email 驗證，寄送重設連結"
}
```

回應
```json
{
  "success": true,
  "data": {
    "draft_id": "draft-uuid-789",
    "draft": {
      "use_case": { "uc_code": "UC-003", "title": "忘記密碼", "summary": "..." },
      "sequence": { "sd_code": "SD-003", "title": "忘記密碼流程", "mermaid_src": "sequenceDiagram\n..." },
      "apis": [
        { "api_code": "API-AUTH-003", "method": "POST", "path": "/auth/forgot-password", "title": "申請重設" }
      ],
      "dtos": [
        { "dto_code": "DTO-ForgotPasswordRequest-001", "title": "ForgotPasswordRequest", "kind": "request", "schema_json": { "type": "object", "properties": {"email": {"type": "string"}}, "required": ["email"] } },
        { "dto_code": "DTO-ForgotPasswordResponse-001", "title": "ForgotPasswordResponse", "kind": "response", "schema_json": {"type": "object", "properties": {"ok": {"type": "boolean"}}, "required": ["ok"]} }
      ]
    }
  }
}
```

採用草稿（原子性操作）：
POST /ai/adopt-draft（需要認證，需要 EDITOR 以上權限）

請求
```json
{
  "draft_id": "draft-uuid-789",
  "project_id": "uuid-123"
}
```

回應
```json
{
  "success": true,
  "data": {
    "adopted_resources": {
      "use_case": { "id": "uuid-1", "uc_code": "UC-003" },
      "sequence": { "id": "uuid-2", "sd_code": "SD-003" },
      "apis": [{ "id": "uuid-3", "api_code": "API-AUTH-003" }],
      "dtos": [
        { "id": "uuid-4", "dto_code": "DTO-ForgotPasswordRequest-001" },
        { "id": "uuid-5", "dto_code": "DTO-ForgotPasswordResponse-001" }
      ],
      "links": [
        { "id": "uuid-6", "type": "api_dto", "api_id": "uuid-3", "dto_id": "uuid-4", "role": "req" },
        { "id": "uuid-7", "type": "api_dto", "api_id": "uuid-3", "dto_id": "uuid-5", "role": "res" }
      ]
    }
  }
}
```

6) 一致性檢查：優化演算法（偽碼）

```python
function checkConsistency(project_id):
  sequences = db.findSequences(project_id)
  referenced_api_codes = {}  # api_code -> [sequence_info]
  missing_refs = {"apis": [], "dtos": []}
  orphans = {"apis": [], "dtos": []}
  
  # 掃描所有循序圖
  for seq in sequences:
    codes = parseApiCodes(seq.mermaid_src)
    for code in codes:
      if code not in referenced_api_codes:
        referenced_api_codes[code] = []
      referenced_api_codes[code].append({
        "sequence_id": seq.id,
        "sequence_title": seq.title,
        "line_number": findLineNumber(seq.mermaid_src, code)
      })
      
      # 檢查 API 是否存在
      api = db.findApiByCode(project_id, code)
      if not api:
        missing_refs.apis.append({
          "api_code": code,
          "referenced_in": referenced_api_codes[code]
        })
      else:
        # 檢查 DTO 綁定
        links = db.findApiDtoLinks(api.id)
        hasReq = any(l.role == 'req' for l in links)
        hasRes = any(l.role == 'res' for l in links)
        
        if not hasReq:
          missing_refs.dtos.append({
            "api_code": api.api_code,
            "missing": "req",
            "api_title": api.title
          })
        if not hasRes:
          missing_refs.dtos.append({
            "api_code": api.api_code,
            "missing": "res",
            "api_title": api.title
          })

  # 找出孤兒 API
  allApis = db.findApis(project_id)
  for api in allApis:
    if api.api_code not in referenced_api_codes:
      orphans.apis.append({
        "api_code": api.api_code,
        "api_title": api.title,
        "created_at": api.created_at
      })

  # 找出孤兒 DTO
  allDtos = db.findDtos(project_id)
  for dto in allDtos:
    if not db.existsApiDtoLink(dto.id):
      orphans.dtos.append({
        "dto_code": dto.dto_code,
        "dto_title": dto.title,
        "created_at": dto.created_at
      })

  return {
    "missing_refs": missing_refs,
    "orphans": orphans,
    "stats": {
      "sequences_scanned": len(sequences),
      "apis_referenced": len(referenced_api_codes),
      "apis_defined": len(allApis),
      "dtos_defined": len(allDtos),
      "links_checked": sum(len(db.findApiDtoLinks(api.id)) for api in allApis)
    }
  }
```

7) 優化資料庫 DDL（PostgreSQL 範例）

7.1 用戶認證相關表

7.1.1 User 表
```sql
CREATE TABLE "user" (
  id                        UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email                     TEXT NOT NULL UNIQUE,
  password                  TEXT NOT NULL,
  name                      TEXT,
  role                      TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'admin', 'super_admin')),
  is_active                 BOOLEAN NOT NULL DEFAULT true,
  is_locked                 BOOLEAN NOT NULL DEFAULT false,
  lock_reason               TEXT,
  failed_login_attempts     INTEGER NOT NULL DEFAULT 0,
  last_login_at             TIMESTAMP,
  last_password_change      TIMESTAMP,
  email_verified            BOOLEAN NOT NULL DEFAULT false,
  email_verification_token  TEXT,
  password_reset_token      TEXT,
  password_reset_expires    TIMESTAMP,
  created_at                TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at                TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX ix_user_email ON "user"(email);
CREATE INDEX ix_user_role ON "user"(role);
CREATE INDEX ix_user_active ON "user"(is_active);
CREATE INDEX ix_user_locked ON "user"(is_locked);
```

7.1.2 RefreshToken 表
```sql
CREATE TABLE refresh_token (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id       UUID NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  token         TEXT NOT NULL UNIQUE,
  device_info   TEXT,
  ip_address    TEXT,
  expires_at    TIMESTAMP NOT NULL,
  is_revoked    BOOLEAN NOT NULL DEFAULT false,
  revoked_at    TIMESTAMP,
  created_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX ix_refresh_token_user ON refresh_token(user_id);
CREATE INDEX ix_refresh_token_token ON refresh_token(token);
CREATE INDEX ix_refresh_token_expires ON refresh_token(expires_at);
CREATE INDEX ix_refresh_token_revoked ON refresh_token(is_revoked);
```

7.1.3 用戶相關觸發器
```sql
-- 自動更新 updated_at
CREATE TRIGGER trigger_update_user_updated_at
  BEFORE UPDATE ON "user"
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- 密碼變更時自動更新 last_password_change
CREATE OR REPLACE FUNCTION update_password_change_time()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.password != OLD.password THEN
    NEW.last_password_change = CURRENT_TIMESTAMP;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_password_change_time
  BEFORE UPDATE ON "user"
  FOR EACH ROW
  EXECUTE FUNCTION update_password_change_time();

-- 登入成功時重置失敗次數
CREATE OR REPLACE FUNCTION reset_failed_login_attempts()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.last_login_at IS NOT NULL AND OLD.last_login_at IS NULL THEN
    NEW.failed_login_attempts = 0;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_reset_failed_login_attempts
  BEFORE UPDATE ON "user"
  FOR EACH ROW
  EXECUTE FUNCTION reset_failed_login_attempts();
```

7.2 流水號計數器表
```sql
CREATE TABLE seq_counter (
  id            BIGSERIAL PRIMARY KEY,
  project_id    UUID NOT NULL,
  scope_type    TEXT NOT NULL CHECK (scope_type IN ('MODULE', 'USE_CASE', 'SEQUENCE', 'API', 'DTO')),
  scope_ref1    TEXT,           -- e.g. module_id / use_case_id / domain / dto_name_base
  scope_ref2    TEXT,           -- 保留欄位
  next_number   BIGINT NOT NULL DEFAULT 1,
  created_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (project_id, scope_type, scope_ref1, scope_ref2)
);

CREATE INDEX ix_seq_counter_project ON seq_counter(project_id);
CREATE INDEX ix_seq_counter_scope ON seq_counter(scope_type, scope_ref1);
```

7.2 Project
```sql
CREATE TABLE project (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  owner_id UUID REFERENCES "user"(id) ON DELETE SET NULL,
  status TEXT NOT NULL DEFAULT 'PLANNING' CHECK (status IN ('PLANNING', 'IN_PROGRESS', 'REVIEW', 'COMPLETED')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX ix_project_name ON project(name);
CREATE INDEX ix_project_owner ON project(owner_id);
CREATE INDEX ix_project_status ON project(status);
```

7.3 ProjectMember（專案成員權限）
```sql
CREATE TABLE project_member (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES project(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('OWNER', 'EDITOR', 'VIEWER')),
  permissions JSONB DEFAULT '{}',
  invited_by UUID REFERENCES "user"(id) ON DELETE SET NULL,
  invited_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  accepted_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX ux_project_member_unique ON project_member(project_id, user_id);
CREATE INDEX ix_project_member_project ON project_member(project_id);
CREATE INDEX ix_project_member_user ON project_member(user_id);
CREATE INDEX ix_project_member_role ON project_member(project_id, role);
```

7.3 Module
```sql
CREATE TABLE module (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES project(id) ON DELETE CASCADE,
  mod_code TEXT NOT NULL,
  title TEXT NOT NULL,
  parent_id UUID REFERENCES module(id) ON DELETE CASCADE,
  "order" INT NOT NULL DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX ux_module_code ON module(project_id, mod_code);
CREATE INDEX ix_module_project ON module(project_id);
CREATE INDEX ix_module_parent ON module(parent_id);
CREATE INDEX ix_module_order ON module(project_id, "order");

-- 自動維護 order 的觸發器
CREATE OR REPLACE FUNCTION update_module_order()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW."order" IS NULL THEN
    SELECT COALESCE(MAX("order"), 0) + 10 INTO NEW."order"
    FROM module 
    WHERE project_id = NEW.project_id AND parent_id IS NOT DISTINCT FROM NEW.parent_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_module_order
  BEFORE INSERT ON module
  FOR EACH ROW
  EXECUTE FUNCTION update_module_order();
```

7.4 UseCase
```sql
CREATE TABLE use_case (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES project(id) ON DELETE CASCADE,
  module_id UUID NOT NULL REFERENCES module(id) ON DELETE CASCADE,
  uc_code TEXT NOT NULL,
  title TEXT NOT NULL,
  summary TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX ux_use_case_code ON use_case(project_id, uc_code);
CREATE INDEX ix_use_case_project ON use_case(project_id);
CREATE INDEX ix_use_case_module ON use_case(module_id);
```

7.5 SequenceDiagram
```sql
CREATE TABLE sequence_diagram (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES project(id) ON DELETE CASCADE,
  use_case_id UUID NOT NULL REFERENCES use_case(id) ON DELETE CASCADE,
  sd_code TEXT NOT NULL,
  title TEXT NOT NULL,
  mermaid_src TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX ux_sequence_code ON sequence_diagram(project_id, sd_code);
CREATE INDEX ix_sequence_project ON sequence_diagram(project_id);
CREATE INDEX ix_sequence_use_case ON sequence_diagram(use_case_id);
```

7.6 ApiContract
```sql
CREATE TABLE api_contract (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES project(id) ON DELETE CASCADE,
  api_code TEXT NOT NULL,
  method TEXT NOT NULL CHECK (method IN ('GET', 'POST', 'PUT', 'DELETE', 'PATCH')),
  path TEXT NOT NULL,
  title TEXT NOT NULL,
  desc TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX ux_api_code ON api_contract(project_id, api_code);
CREATE INDEX ix_api_project ON api_contract(project_id);
CREATE INDEX ix_api_method_path ON api_contract(project_id, method, path);
CREATE UNIQUE INDEX ux_api_method_path_unique ON api_contract(project_id, method, path);
```

7.7 DtoSchema
```sql
CREATE TABLE dto_schema (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES project(id) ON DELETE CASCADE,
  dto_code TEXT NOT NULL,
  title TEXT NOT NULL,
  schema_json JSONB NOT NULL,
  kind TEXT NOT NULL CHECK (kind IN ('request', 'response')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX ux_dto_code ON dto_schema(project_id, dto_code);
CREATE INDEX ix_dto_project ON dto_schema(project_id);
CREATE INDEX ix_dto_kind ON dto_schema(project_id, kind);
CREATE INDEX ix_dto_schema_gin ON dto_schema USING GIN (schema_json);
```

7.8 Links
```sql
CREATE TABLE api_sequence_link (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_id UUID NOT NULL REFERENCES api_contract(id) ON DELETE CASCADE,
  sequence_id UUID NOT NULL REFERENCES sequence_diagram(id) ON DELETE CASCADE,
  step_ref TEXT,
  line_number INT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX ix_api_sequence_api ON api_sequence_link(api_id);
CREATE INDEX ix_api_sequence_sequence ON api_sequence_link(sequence_id);
CREATE UNIQUE INDEX ux_api_sequence_unique ON api_sequence_link(api_id, sequence_id, step_ref);

CREATE TABLE api_dto_link (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_id UUID NOT NULL REFERENCES api_contract(id) ON DELETE CASCADE,
  dto_id UUID NOT NULL REFERENCES dto_schema(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('req', 'res')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX ix_api_dto_link_api ON api_dto_link(api_id);
CREATE INDEX ix_api_dto_link_dto ON api_dto_link(dto_id);
CREATE UNIQUE INDEX ux_api_dto_role_unique ON api_dto_link(api_id, dto_id, role);
```

7.9 更新時間觸發器
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 為所有需要 updated_at 的表添加觸發器
CREATE TRIGGER trigger_update_project_updated_at
  BEFORE UPDATE ON project
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_module_updated_at
  BEFORE UPDATE ON module
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_use_case_updated_at
  BEFORE UPDATE ON use_case
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_sequence_diagram_updated_at
  BEFORE UPDATE ON sequence_diagram
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_api_contract_updated_at
  BEFORE UPDATE ON api_contract
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_dto_schema_updated_at
  BEFORE UPDATE ON dto_schema
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

8) 資料安全與權限控制

8.1 資料過濾邏輯

8.1.1 專案查詢過濾
- 所有專案相關查詢都必須基於使用者權限進行過濾
- 使用者只能看到有權限的專案（OWNER、EDITOR、VIEWER）
- 查詢時自動加入 `project_id IN (SELECT project_id FROM project_member WHERE user_id = ?)` 條件

8.1.2 權限檢查實作
```typescript
// project.service.ts 中的 findAll 方法
async findAll(params: ProjectListParams = {}, userId: string): Promise<{
  data: Project[];
  total: number;
  page: number;
  totalPages: number;
}> {
  const {
    page = 1,
    limit = 10,
    search,
    status,
    sortBy = 'createdAt',
    sortOrder = 'desc',
  } = params;

  const skip = (page - 1) * limit;
  
  const where: Prisma.ProjectWhereInput = {
    // 權限過濾：只顯示有權限的專案
    OR: [
      { ownerId: userId }, // 擁有者
      { 
        members: { 
          some: { 
            userId: userId,
            role: { in: ['OWNER', 'EDITOR', 'VIEWER'] }
          } 
        } 
      }
    ]
  };
  
  if (search) {
    where.AND = [{
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
        { projectCode: { contains: search, mode: 'insensitive' } },
      ]
    }];
  }
  
  if (status) {
    where.status = status;
  }

  const [data, total] = await Promise.all([
    this.prisma.project.findMany({
      where,
      skip,
      take: limit,
      orderBy: { [sortBy]: sortOrder },
      include: {
        members: {
          where: { userId },
          select: { role: true }
        }
      }
    }),
    this.prisma.project.count({ where }),
  ]);

  return {
    data,
    total,
    page,
    totalPages: Math.ceil(total / limit),
  };
}
```

8.2 併發處理與效能優化

8.2.1 流水號分配優化

- 使用 Redis 分散式鎖，避免資料庫鎖競爭
- 批量建立時預分配號碼範圍，減少鎖定次數
- 失敗重試使用指數退避策略

8.2 Mermaid 解析優化

- 使用 Worker Pool 處理大量解析任務
- 解析結果快取，避免重複解析
- 增量解析：只解析變更的部分

8.3 查詢效能優化

- 複合索引支援多條件查詢
- 分頁查詢使用游標分頁（Cursor-based Pagination）
- 大量資料使用非同步處理

9) 錯誤處理、日誌與安全監控

9.1 錯誤代碼定義

**認證與權限相關錯誤**：
- AUTH_TOKEN_MISSING：缺少認證 Token
- AUTH_TOKEN_INVALID：Token 無效
- AUTH_TOKEN_EXPIRED：Token 已過期
- AUTH_TOKEN_REVOKED：Token 已被撤銷
- PERMISSION_DENIED：無權限存取此專案
- INSUFFICIENT_PERMISSION：權限不足
- PROJECT_ACCESS_DENIED：專案存取被拒絕
- MEMBER_NOT_FOUND：專案成員不存在
- INVITATION_EXPIRED：邀請已過期
- INVITATION_ALREADY_ACCEPTED：邀請已被接受

**認證相關錯誤**：

**認證相關錯誤**：
- AUTH_INVALID_CREDENTIALS：無效的登入憑證
- AUTH_ACCOUNT_LOCKED：帳號已被鎖定
- AUTH_ACCOUNT_INACTIVE：帳號未啟用
- AUTH_TOKEN_EXPIRED：Token 已過期
- AUTH_TOKEN_INVALID：Token 無效
- AUTH_TOKEN_REVOKED：Token 已被撤銷
- AUTH_INSUFFICIENT_PERMISSION：權限不足
- AUTH_TOO_MANY_ATTEMPTS：登入嘗試次數過多
- AUTH_PASSWORD_TOO_WEAK：密碼強度不足
- AUTH_EMAIL_NOT_VERIFIED：Email 未驗證

**業務邏輯錯誤**：
- VALIDATION_ERROR：資料驗證失敗
- NOT_FOUND：資源不存在
- DUPLICATE_CODE：代碼重複
- CONSISTENCY_ERROR：一致性檢查失敗
- SYSTEM_ERROR：系統內部錯誤

9.2 日誌記錄與安全監控

9.2.1 稽核日誌
- 所有 CRUD 操作記錄到稽核日誌
- 專案存取記錄（成功/失敗）
- 權限變更記錄
- 成員邀請/移除記錄
- 代碼生成失敗記錄到錯誤日誌
- 一致性檢查結果記錄到系統日誌
- 支援結構化日誌，便於分析

9.2.2 安全監控
- 登入失敗次數監控
- 異常存取模式檢測
- Token 濫用檢測
- 權限提升嘗試監控
- 大量資料查詢監控
- 可疑 IP 位址追蹤

10) 部署與監控

10.1 健康檢查

- GET /health：基本健康狀態
- GET /health/db：資料庫連線狀態
- GET /health/consistency：一致性檢查狀態

10.2 效能監控

- API 響應時間監控
- 資料庫查詢效能監控
- 記憶體與 CPU 使用率監控

10.3 備份策略

- 定期備份資料庫
- 代碼生成記錄備份
- 災難恢復方案

這份優化版規格解決了原始版本的所有主要問題，提供了更穩定、高效、可維護的系統設計。

## 🔐 安全實作檢查清單

### 實作順序
1. **建立認證中介軟體** (`auth.middleware.ts`)
   - JWT Token 驗證
   - 使用者資訊解析
   - 錯誤處理

2. **建立權限檢查中介軟體** (`permission.middleware.ts`)
   - 專案權限驗證
   - 角色權限檢查
   - 權限不足處理

3. **修改資料庫結構**
   - 新增 `project_member` 表
   - 修改 `project` 表，加入 `owner_id` 和 `status` 欄位
   - 建立必要的索引

4. **修改專案服務**
   - 加入權限過濾邏輯
   - 實作成員管理功能
   - 加入權限檢查

5. **修改所有業務路由**
   - 加入認證中介軟體
   - 加入權限檢查中介軟體
   - 移除 `@access Public` 標記

6. **加入稽核日誌**
   - 記錄所有存取操作
   - 記錄權限變更
   - 記錄安全事件

### 安全注意事項
- **Token 安全**：使用強密碼作為 JWT Secret，定期輪換
- **權限最小化**：使用者只能存取必要的資源
- **輸入驗證**：所有輸入都必須經過驗證和清理
- **SQL 注入防護**：使用 Prisma ORM 避免 SQL 注入
- **XSS 防護**：輸出時進行適當的編碼
- **CSRF 防護**：使用適當的 CSRF Token
- **速率限制**：實作 API 速率限制防止濫用
- **日誌安全**：避免記錄敏感資訊，保護日誌檔案

### 測試要求
- **認證測試**：測試各種認證場景
- **權限測試**：測試不同角色的權限
- **安全測試**：測試常見的安全漏洞
- **效能測試**：確保權限檢查不影響效能
- **整合測試**：測試完整的認證和權限流程